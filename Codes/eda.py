# -*- coding: utf-8 -*-
"""EDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16fe3XoQbCg3YQguSzbV-2ysCEwphl_PS

#Requirements
1. Numpy
2. Pandas
3. Scipy
4. matplotlib
5. seaborn
6. sklearn
7. plotly
"""

# here we will import the libraries used 
import numpy as np                                      # linear algebra
import pandas as pd                                     # data processing, CSV file I/O (e.g. pd.read_csv)
from scipy.stats import randint
import pandas as pd                                     # data processing, CSV file I/O, data manipulation 
import matplotlib.pyplot as plt                         # this is used for the plot the graph 
import seaborn as sns                                   # used for plot interactive graph. 
from pandas import set_option
plt.style.use('ggplot')                                 # nice plots

import plotly.graph_objs as go
from plotly.subplots import make_subplots
import plotly.io as pio
pio.templates.default = "plotly_dark"

pio.templates.default = "ggplot2"

df = pd.read_csv("Credit_default_dataset.csv")

"""# Basic Information about dataset"""

nRow, nCol = df.shape
print(f'There are {nRow} rows and {nCol} columns')

"""* ID: ID of each client
*LIMIT_BAL: Amount of given credit in NT dollars (includes individual and family/supplementary credit
*SEX: Gender (1=male, 2=female)
*EDUCATION: (1=graduate school, 2=university, 3=high school, 4=others, 5=unknown, 6=unknown)
*MARRIAGE: Marital status (1=married, 2=single, 3=others)
*AGE: Age in years
*PAY_0: Repayment status in September, 2005 (-1=pay duly, 1=payment delay for one month, 2=payment delay for two months, … 8=payment delay for eight months, 9=payment delay for nine months and above)
*PAY_2: Repayment status in August, 2005 (scale same as above)
*PAY_3: Repayment status in July, 2005 (scale same as above)
*PAY_4: Repayment status in June, 2005 (scale same as above)
*PAY_5: Repayment status in May, 2005 (scale same as above)
*PAY_6: Repayment status in April, 2005 (scale same as above)
*BILL_AMT1: Amount of bill statement in September, 2005 (NT dollar)
*BILL_AMT2: Amount of bill statement in August, 2005 (NT dollar)
*BILL_AMT3: Amount of bill statement in July, 2005 (NT dollar)
*BILL_AMT4: Amount of bill statement in June, 2005 (NT dollar)
*BILL_AMT5: Amount of bill statement in May, 2005 (NT dollar)
*BILL_AMT6: Amount of bill statement in April, 2005 (NT dollar)
*PAY_AMT1: Amount of previous payment in September, 2005 (NT dollar)
*PAY_AMT2: Amount of previous payment in August, 2005 (NT dollar)
*PAY_AMT3: Amount of previous payment in July, 2005 (NT dollar)
*PAY_AMT4: Amount of previous payment in June, 2005 (NT dollar)
*PAY_AMT5: Amount of previous payment in May, 2005 (NT dollar)
*PAY_AMT6: Amount of previous payment in April, 2005 (NT dollar)
*default.payment.next.month: Default payment (1=yes, 0=no)
"""

pd.set_option('display.max_columns', None)
df.head(5)

df.info()

#For easy Understanding changing some names
df.rename(columns={'default.payment.next.month':'defaulter'}, inplace=True)
df.rename(columns={'PAY_0':'PAY_1'}, inplace=True)

df.describe().T

#Checking for missing values
df.isna().sum()

# check unique values in different features
print(df.EDUCATION.unique())
print(df.MARRIAGE.unique())

fil = (df['EDUCATION'] == 5) | (df['EDUCATION'] == 6) | (df['EDUCATION'] == 0)
df.loc[fil, 'EDUCATION'] = 4
df['EDUCATION'].value_counts()

fil = (df['MARRIAGE'] == 0)
df.loc[fil, 'MARRIAGE'] = 3
df['MARRIAGE'].value_counts()



"""# Exploratory Data Analysis (EDA)"""

# The frequency of defaults
yes = df.defaulter.sum()
no = len(df)-yes

# Percentage
yes_perc = round(yes/len(df)*100, 1)
no_perc = round(no/len(df)*100, 1)


plt.figure(figsize=(10,8))
sns.set_context('notebook', font_scale=1.2)
sns.countplot('defaulter',data=df, palette="Blues")
plt.annotate('Non-default: {}'.format(no), xy=(-0.3, 15000), xytext=(-0.3, 3000), size=12)
plt.annotate('Default: {}'.format(yes), xy=(0.7, 15000), xytext=(0.7, 3000), size=12)
plt.annotate(str(no_perc)+" %", xy=(-0.3, 15000), xytext=(-0.1, 8000), size=12)
plt.annotate(str(yes_perc)+" %", xy=(0.7, 15000), xytext=(0.9, 8000), size=12)
plt.title('COUNT OF CREDIT CARDS', size=14)

"""We can see that the dataset consists of 77% clients are not expected to default payment whereas 23% clients are expected to default the payment.

### Categorical Features
"""

def cross(Col1, Col2):
    res = pd.crosstab(df[Col1], df[Col2])
    #Calculating the percentage of defaulters
    res['Percentage'] = round((res[res.columns[1]]/(res[res.columns[0]] + res[res.columns[1]])) * 100,2)
    print(res)
    #Plotting a stack bar graph
    fig = go.Figure(data=[
    go.Bar(name='Non-Defaulters', x=res.index.to_list(),y=res[0]),
    go.Bar(name='Defaulters', x=res.index.to_list(), y=res[1],text=(res['Percentage']),textposition = "outside")])
    # Change the bar mode to stack
    fig.update_layout(barmode='stack',title_text = res.index.name + " variable v/s target" ,xaxis_title=res.index.name,yaxis_title="Number of count")
    fig.show()

"""1. SEX"""

cross("SEX","defaulter")
#1 => Male
#2 => Female

"""Comments: Percenatage of defaulters is more in male then female. Also female client is also high in number

2. EDUCATION
"""

cross("EDUCATION","defaulter")

"""Comments: Most defaulters have education level of university followed by graduate school

3. MARRIAGE
"""

cross("MARRIAGE","defaulter")

"""Comments: Most of the clients are either marrined or single (less frequent the other status).

### Numerical features

1. AGE And LIMIT_BAL
"""

plt.subplots(figsize=(20,5))
plt.subplot(121)
sns.distplot(df.LIMIT_BAL)

plt.subplot(122)
sns.distplot(df.AGE)

plt.show()

"""By plotting the continous variables we observe that dataset consists of skewed data of limiting balance and age of clients.
We have more number of clients having limiting balance between 0 to 200000 currency.
We have more number of clients from age bracket of 20 to 40, i.e., clients from mostly young to mid aged groups.
"""

fig = go.Figure()
fig.add_trace(go.Histogram(x = df[df['defaulter'] == 0]["AGE"],marker_color="green",name="Non-defaulters"))
fig.add_trace(go.Histogram(x = df[df['defaulter'] == 1]["AGE"],marker_color="orange",name="Defaulters"))
# Overlay both histograms
fig.update_layout(barmode='overlay')
# Reduce opacity to see both histograms
fig.update_traces(opacity=0.75)
fig.update_layout(title="Distribution of age of defaulters and non-defaulters",xaxis_title="AGE",yaxis_title="Counts")
fig.show()

"""The distribution is almost uniformly distributed but a bit right skewed for the defaulters. But it shows that old age people are almost non-defaulters"""

x1 = list(df[df['defaulter'] == 1]['LIMIT_BAL'])
x2 = list(df[df['defaulter'] == 0]['LIMIT_BAL'])

plt.figure(figsize=(12,4))
sns.set_context('notebook', font_scale=1.2)
#sns.set_color_codes("pastel")
plt.hist([x1, x2], bins = 40, color=['steelblue', 'lightblue'])
plt.xlim([0,600000])
plt.legend(['Yes', 'No'], title = 'Default', loc='upper right', facecolor='white')
plt.xlabel('Limit Balance (NT dollar)')
plt.ylabel('Frequency')
plt.title('LIMIT BALANCE HISTOGRAM BY TYPE OF CREDIT CARD', SIZE=15)
plt.box(False)
#plt.savefig('ImageName', format='png', dpi=200, transparent=True);

"""Comments: Clients having lower Balance have more chances of default then higher Balance

2. Amount of bill statement in different months
"""

bills = df[['BILL_AMT1','BILL_AMT2', 'BILL_AMT3', 'BILL_AMT4', 'BILL_AMT5', 'BILL_AMT6']]

fig =  make_subplots(rows= 3, cols=2,subplot_titles=bills.columns.to_list())  

fig.add_trace(go.Histogram(x= df["BILL_AMT1"],name='BILL_AMT1'),row = 1, col = 1)
fig.add_trace(go.Histogram(x= df["BILL_AMT2"],name='BILL_AMT2'),row = 2, col = 2)
fig.add_trace(go.Histogram(x= df["BILL_AMT3"],name='BILL_AMT3'),row = 3, col = 1)
fig.add_trace(go.Histogram(x= df["BILL_AMT4"],name='BILL_AMT4'),row = 1, col = 2)
fig.add_trace(go.Histogram(x= df["BILL_AMT5"],name='BILL_AMT5'),row = 2, col = 1)
fig.add_trace(go.Histogram(x= df["BILL_AMT6"],name='BILL_AMT6'),row = 3, col = 2)


fig.update_layout(height=600, width=800, title_text="Histogram Subplots of Bill Amount")
fig.show()

"""3. Amount of previous payments in  different months"""

pay = df[['PAY_AMT1','PAY_AMT2', 'PAY_AMT3', 'PAY_AMT4', 'PAY_AMT5', 'PAY_AMT6']]
fig = make_subplots(rows= 3, cols=2,subplot_titles=pay.columns.to_list())  

fig.add_trace(go.Histogram(x= df["PAY_AMT1"],name='PAY_AMT1'),row = 1, col = 1)
fig.add_trace(go.Histogram(x= df["PAY_AMT2"],name='PAY_AMT2'),row = 2, col = 2)
fig.add_trace(go.Histogram(x= df["PAY_AMT3"],name='PAY_AMT3'),row = 3, col = 1)
fig.add_trace(go.Histogram(x= df["PAY_AMT4"],name='PAY_AMT4'),row = 1, col = 2)
fig.add_trace(go.Histogram(x= df["PAY_AMT5"],name='PAY_AMT5'),row = 2, col = 1)
fig.add_trace(go.Histogram(x= df["PAY_AMT6"],name='PAY_AMT6'),row = 3, col = 2)


fig.update_layout(height=600, width=800, title_text="Histogram Subplots of Amount of Previous Payment")
fig.show()

"""Highely Skewed Data, we need tranformations during training

4. Repayment status in different months
"""

pay_s = df[['PAY_1','PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6']]
df['PAY_1'].value_counts().index.to_list().sort()
fig = make_subplots(rows= 3, cols=2,subplot_titles=pay_s.columns.to_list())  

fig.add_trace(go.Histogram(x= df["PAY_1"],name='PAY_1'),row = 1, col = 1)
fig.add_trace(go.Histogram(x= df["PAY_2"],name='PAY_2'),row = 2, col = 2)
fig.add_trace(go.Histogram(x= df["PAY_3"],name='PAY_3'),row = 3, col = 1)
fig.add_trace(go.Histogram(x= df["PAY_4"],name='PAY_4'),row = 1, col = 2)
fig.add_trace(go.Histogram(x= df["PAY_5"],name='PAY_5'),row = 2, col = 1)
fig.add_trace(go.Histogram(x= df["PAY_6"],name='PAY_6'),row = 3, col = 2)


fig.update_layout(bargap=0.2,height=600, width=800, title_text="Histogram Subplots of Previous Payment Status")
fig.show()

subset = df[[ 'PAY_1', 'PAY_2', 'PAY_3', 'PAY_4', 
               'PAY_5', 'PAY_6', 'defaulter']]

f, axes = plt.subplots(3, 2, figsize=(20, 15), facecolor='white')
f.suptitle('FREQUENCY OF CATEGORICAL VARIABLES (BY TARGET)')
ax1 = sns.countplot(x="PAY_1", hue="defaulter", data=subset, palette="Blues",ax=axes[0,0])
ax2 = sns.countplot(x="PAY_2", hue="defaulter", data=subset, palette="Blues",ax=axes[0,1])
ax3 = sns.countplot(x="PAY_3", hue="defaulter", data=subset, palette="Blues",ax=axes[1,0])
ax4 = sns.countplot(x="PAY_4", hue="defaulter", data=subset, palette="Blues",ax=axes[1,1])
ax5 = sns.countplot(x="PAY_5", hue="defaulter", data=subset, palette="Blues",ax=axes[2,0])
ax6 = sns.countplot(x="PAY_6", hue="defaulter", data=subset, palette="Blues",ax=axes[2,1]);

"""Comments: Above plot shows us the proportion of clients that will default payment next month based on repayment history.
For Current month status, the earlier the payment is made lesser are the chances of those clients defaulting the payment.
"""

Repayment = df[['PAY_1', 'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6']]

Repayment = pd.concat([df.defaulter,Repayment],axis=1)
Repayment = pd.melt(Repayment,id_vars="defaulter",
                    var_name="Repayment_Status",
                    value_name='value')

plt.figure(figsize=(10,5))
sns.set_context('notebook', font_scale=1.2)
sns.boxplot(y="value", x="Repayment_Status", hue="defaulter", data=Repayment, palette='Blues')
plt.legend(loc='best', title= 'Default', facecolor='white')
plt.xlim([-1.5,5.5])
plt.title('REPAYMENT STATUS - BOXPLOT', size=14)
plt.box(False)
plt.savefig('ImageName', format='png', dpi=200);

"""It seems that PAY_1 (Repayment status in September) and PAY_2 (Repayment status in August) have more discriminatory power the repayment status in other months.

## Standardizing and plotting the data
"""

plt.figure(figsize=(15,7))
ax= df.drop('defaulter', axis=1).boxplot(df.columns.name, rot=90)
outliers = dict(markerfacecolor='b', marker='p')
plt.xticks(size=12)
plt.box(False);

"""The above boxplot reveals that features are in different scales and units. Many models use some form of distance when making predictions, and therefore, it is recommended to normalize the data."""

features = df.drop('defaulter', axis = 1, inplace = False)
stdX = (features - features.mean()) / (features.std())              # standardization
data_st = pd.concat([df.defaulter,stdX.iloc[:,:]],axis=1)
data_st = pd.melt(data_st,id_vars="defaulter",
                    var_name="features",
                    value_name='value')
plt.figure(figsize=(20,10))
sns.set_context('notebook', font_scale=1)
sns.violinplot(y="value", x="features", hue="defaulter", data=data_st,split=True, 
               inner="quart", palette='Blues')
plt.legend(loc=4, title= 'Default', facecolor='white')
plt.ylim([-3,3])
plt.title('STANDARDIZED FEATURES - VIOLIN PLOT', size=14)
plt.box(False)
plt.savefig('ImageName', format='png', dpi=200, transparent=False);

"""Above Standardization of data was performed; i.e, all features are centered around zero and have variance one. Features were plotted again, using a violin plot.

## Correlation

A correlation matrix of all variables is shown in the heatmap below. The only feature with a notable positive correlation with the dependent variable ‘defaulter’ is re-payment status during the last month (September). The highest negative correlation with default occurs with Limit_Balance, indicating that customers with lower limit balance are more likely to default. It can also be observed that some variables are highly correlated to each other, that is the case of the amount of bill statement and the repayment status in different months.
"""

plt.subplots(figsize=(30,20))
sns.heatmap(df.corr(), annot=True)
plt.show()

"""## Some Usefull insight using more than one feature in combination:"""

g = sns.FacetGrid(df, row='defaulter', col='MARRIAGE')
g = g.map(plt.hist, 'AGE')
plt.show()

"""Comments: From above plot we can infer that married people between age bracket of 30 and 50 and unmarried clients of age 20-30 tend to default payment with unmarried clients higher probability to default payment. Hence we can include MARRIAGE feature of clients to find probability of defaulting the payment next month"""

g = sns.FacetGrid(df, row='defaulter', col='SEX')
g = g.map(plt.hist, 'AGE')

"""Comments: It can be seen that females of age group 20-30 have very high tendency to default payment compared to males in all age brackets. Hence we can keep the SEX column of clients to predict probability of defaulting payment."""

def get_group (age):
        if age < 40:
            return "Young"
        elif age >= 60:
            return "Old"
        else:
            return "Middle"

# apply to "AGE" and create a new column
df["Age_group"] = df["AGE"].apply(get_group)

print("Grouped age and education background vs Default Rate")

sns.barplot(x = 'Age_group', y = "defaulter", data = df, hue = "EDUCATION")
plt.show()

"""Commnets: the default rate of customer having High School Education background is very close across all age agroup
The default rate of customer having University and Graduate School Education background is high for Old Age >Group, and reletively low for Young and Middle age group
"""

plt.figure(figsize=(18,18))
sns.pairplot(df)
plt.show()

